import { useState, useEffect, useRef } from "react";
import { useLocation } from "react-router-dom";
/**
 * Handle messages pagination
 * @param {array} messages (group of messages: { author, timestamp, messages: []})
 * @param {HTMLElement} ref (messages container)
 */
function useScroll(messages, ref) {
  const [isFirst, setIsFirst] = useState(true); // First loading
  const [hasScrolled, setHasScrolled] = useState(false); // If the user has scrolled, display a button to scroll back to present.
  const previous = useRef(); // Used to know if previous messages were loaded, or if a new one was added.
  const currentHeight = useRef(); // Calculate the scroll after loading new messages
  const location = useLocation(); // Used to reset the scroll when changing room.

  /** Scroll to bottom */
  const scrollToBottom = () => {
    ref.current.scrollTop = ref.current.scrollHeight - ref.current.clientHeight;
    currentHeight.current = ref.current.scrollHeight;
  };

  /** Update the state after the user scrolls */
  const handleScroll = () => {
    if (!ref.current) return;
    if (
      ref.current.scrollHeight - ref.current.scrollTop >
      ref.current.clientHeight * 2
    ) {
      setHasScrolled(true);
    } else {
      setHasScrolled(false);
    }
  };

  /**
   * -- Automatic scroll --
   * If it is the messages first render:
   * - Scroll to the bottom
   * - Set up ref.
   *
   * Saves the first and last messages in a reference.
   * When the messages props change, the component will know whether the new messages
   * appeared on top (=previous messages have been loaded) or on the bottom (=someone
   * wrote a new message).
   *
   * - If previous messages were loaded, the scroll position remains the same.
   * - If a new message was written:
   *    * If the user is already at the bottom of the messages list, scroll to the bottom after
   *      the new message appears.
   *    * If the user was scrolling to read previous messages, don't scroll to the bottom
   *      automatically.
   */

  /* After changing location:
   * - Handle the scroll for the first render of messages.
   * - Since it leads to a scroll back to bottom, set hasScrolled to false.
   */
  useEffect(() => {
    setIsFirst(true);
    setHasScrolled(false);
  }, [location.key]);

  useEffect(() => {
    if (!ref || messages.length < 1 || !isFirst) return;
    ref.current.scrollTop = ref.current.scrollHeight - ref.current.clientHeight;

    currentHeight.current = ref.current.scrollHeight;
    previous.current = {
      first: messages[0]._id,
      last: messages[messages.length - 1].messages[
        messages[messages.length - 1].messages.length - 1
      ]._id,
    };

    setIsFirst(false);
  }, [messages, ref]);

  // When messages change, compare to the refs and scroll in consequence.
  useEffect(() => {
    // If there were / are no messages, do nothing.
    if (messages.length < 1 || !previous?.current) return;

    // Previous messages were loaded
    if (messages[0]._id < previous.current.first) {
      ref.current.scrollTop = ref.current.scrollHeight - currentHeight.current;
      currentHeight.current = ref.current.scrollHeight;
    }

    // A new message was written and the user was near the bottom
    // Scroll them to the bottom.
    const latestMessage =
      messages[messages.length - 1].messages[
        messages[messages.length - 1].messages.length - 1
      ];

    /**
     * Note: latestMessage will not have an id if it is written by the current user
     * as it is inserted before being sent to the DB and before obtaining
     * an id generated by MongoDB.
     * In that case, scroll to the bottom too.
     */

    if (
      (latestMessage._id > previous.current.last || !latestMessage._id) &&
      ref.current.scrollHeight - ref.current.clientHeight <
        ref.current.scrollTop + 500
    ) {
      ref.current.scrollTop =
        ref.current.scrollHeight - ref.current.clientHeight;
    }

    // Update the previous ref.
    previous.current = {
      first: messages[0]._id,
      last: messages[messages.length - 1].messages[
        messages[messages.length - 1].messages.length - 1
      ]._id,
    };
  }, [messages]);

  return {
    scrollToBottom,
    hasScrolled,
    handleScroll,
  };
}

export default useScroll;
